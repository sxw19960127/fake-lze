# `Promise`

遵循`Promise A+`规范。

```js
// 回调地狱
setTimeout(function() {
	setTimeout(function() {
		setTimeout(function() {
			setTimeout(function() {
				setTimeout(function() {
					// ...
				}, 1000)
			}, 1000)
		}, 1000)
	}, 1000)
}, 1000)
```

## `Promise`的三个状态

- `pending` 等待 
- 成功 
- 失败 

**注意**：`Promise`刚创建出来是`pending`状态，调用`resolved`变成成功状态，调用`rejected`变成失败状态。`Promise`的状态只能从`pending`变为成功状态或者从`pending`变为失败状态，仅此两种而已。

```js
// new Promise之后,后面的函数立即执行
const p = new Promise((resolved,rejected) => { 
	resolved(200)
});
p.then(function(val) {
	console.log(val)
},function(err) {
	console.log(err)
})
```

```js
const p = new Promise((resolved,rejected) => {
	rejected(new Error("错误了"))
});
p.then(function(val) {
	console.log(val)
},function(err) {
	console.log(err)
})
```

```js
const p = new Promise((resolved,rejected) => {
	rejected(new Error("错误了"))
});
p.then(function(val) {
	console.log(val)
}).catch(function(err) { // 错误还可以通过 .catch 进行抛出
	console.log(err)
})
```

```js
const p = new Promise((resolved,rejected) => {
	setTimeout(function() {
		resolved(1000);
	},1000)
});
p.then(function(val) {
	console.log(val)
},function(err) {
	console.log(err)
})
```

解读：执行`setTimeout`中的代码，发现是一个异步操作，把这个异步放到事件队列中，继续往下执行，执行`p.then`，这时候`p`的状态是`pending`，既没有调用`resolved`方法，也没有调用`rejected`方法，`.then`什么都不执行，仅仅注册了一个事件，将成功的事件和失败的事件注册了，等1秒后成功了就会调用成功的事件，失败了就会调用失败的事件，`promise`相当于一个占位符，对未来的值进行了操作。

```js
const p = new Promise((resolved,rejected) => {
	setTimeout(function() {
		resolved(200);
	})
});
p.then(function(val) {
	console.log(val) // 200
	return undefined // 这行代码不写,默认也是会返回undefined的,undefined不是promise对象
},function(err) {
	console.log(err)
}).then(function(val) { // 上述return值不是promise对象,走成功回调
	console.log(val) // 200
},function() {
	console.log(100)
})
```

链式调用`promise`，解决了回调金字塔问题。

`p.then`会返回一个新的`promise`对象，`p.then`返回的`promise`对象，它看上一个回调函数的返回值，如果`return`值不是一个`promise`对象的话，表示成功状态，指向成功对应的回调函数。如果`return`的值是一个`promise`对象，则继续看`promise`中的状态以作决定。

```js
const p = new Promise((resolved,rejected) => {
	setTimeout(function() {
		resolved(200);
	})
});
p.then(function(val) {
	console.log(val) // 200
	return new Promise((resolved,rejected) => { // return的状态决定了外面p.then的状态
        setTimeout(() => {
            resolved(1) 
        }, 2000)
    })
},function(err) {
	console.log(err)
}).then(function(val) {
	console.log(val) // 1
},function() {
	console.log(222)
})
```

```js
const p = new Promise((resolved,rejected) => {
	setTimeout(function() {
		resolved(200);
	},1000)
});
p.then(function(val) {
	console.log(val) // 200,1s之后打印
	return new Promise((resolved,rejected) => {  
        setTimeout(() => {
            rejected(404)
        }, 2000)
    })
},function(err) {
	console.log(err)
}).then(function(val) {
	console.log(val)  
}).catch(function(err) {
    throw Error(err) // 404,2s之后打印
})
```

```js
// 使用Promise解决回调地域问题
function fakeAjax(ms, val) {
	return new Promise((resolved,rejected) => {
		setTimeout(function() {
			resolved(val);
		}, ms)
	})
}
fakeAjax(1000,10).then((val) => {
	console.log(val)
	return fakeAjax(2000,20)
}, () => {}).then((val) => {
	console.log(val)
	return fakeAjax(3000,30)
}).then(function(val) {
	console.log(val)
})
```

## `Promise.all()`

响应多个`Promise`对象，当所有对象都成功时，才会返回最后成功结果。

`Promise.all()`自然也会返回一个新的`Promise`对象，可以使用`.then()`方法。

```js
function fakeAjax(ms, val) {
	return new Promise((resolved,rejected) => {
		setTimeout(function() {
			resolved(val);
		}, ms)
	})
}
// 有三个异步事件
var p1 = fakeAjax(1000,10);
var p2 = fakeAjax(2000,20);
var p3 = fakeAjax(3000,30);
// 当三个异步事件都请求结束并且成功后
Promise.all([p1,p2,p3]).then(function(val) { 
	console.log(val)
}, function() {
	// ...
})
```

```js
function fakeAjax(ms,val,flag) {
	return new Promise((resolved,rejected) => {
		setTimeout(function() {
			if(flag) {
                resolved(val)
            }else {
                rejected(val)
            }
		}, ms)
	})
}
// 有三个异步请求事件,其中第三个请求失败
var p1 = fakeAjax(1000,10,true);
var p2 = fakeAjax(2000,20,true);
var p3 = fakeAjax(3000,new Error('出错了'), false);

Promise.all([p1,p2,p3]).then(function(val) { 
	console.log(val)
}).catch((err) => {
    throw(err)
})
```

## `Promise.race()`

根据请求响应最快的那个事件的结果作为决定是走成功的回调函数还是失败的回调函数。

```js
function fakeAjax(ms, val,flag) {
	return new Promise((resolved,rejected) => {
		setTimeout(function() {
			if(flag) {
                resolved(val)
            }else {
                rejected(val)
            }
		}, ms)
	})
}
var p1 = fakeAjax(1000,10,true);
var p2 = fakeAjax(2000,20,true);
var p3 = fakeAjax(300,new Error('出错了'), false);
Promise.race([p1,p2,p3]).then(function(val) { 
	console.log(val)
}, function(err) {  
	console.log(err)
})
```